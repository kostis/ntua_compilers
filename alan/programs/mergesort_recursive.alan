main () : proc

mergeSort (x: reference int [], l: int, r: int) : proc
    merge (x: reference int [], start: int, mid: int, end: int) : proc
	-- through recursion create a "recursive array" in callstack (through the 'cur' variables).
	aux (x_itr: int, l: int, r: int) : proc
	    -- given the scope rules variables x, mid, end are visible inside aux.
	    cur : int;
	{
	        if (x_itr >= end) return;

		if (l < mid & r < end) {
			if (x[l] < x[r]) {
				cur = x[l];
				l = l+1;
			} else {
				cur = x[r];
				r = r+1;
			}
		} else if (l < mid) {
			cur = x[l];
			l = l+1;
		} else return; -- r < end, in which case these elements are already in correct position

		aux(x_itr+1, l, r);
		x[x_itr] = cur;
	}
    {
	aux(start, start, mid);
    }
{
	-- sort [l,r) segment
	if (l == r-1) return;
	mergeSort(x, l, (l+r)/2);
	mergeSort(x, (l+r)/2, r);
	
	-- merge (separate function to allocate local variables in them and reduce stack consumption)
	merge(x, l, (l+r)/2, r);
}

	x : int [10000];
	n : int;
	i : int;
{
	n = readInteger();
	
	if (n <= 0) return;

	i = 0;
	while (i < n) {
		x[i] = readInteger();
		i = i+1;
	}

	mergeSort(x, 0, n);
	
	writeInteger(x[0]);
	i = 1;
	while (i < n) {
		writeChar(' ');
		writeInteger(x[i]);
		i = i+1;
	}
	writeChar('\n');
}

